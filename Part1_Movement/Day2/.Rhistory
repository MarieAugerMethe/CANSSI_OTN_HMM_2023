# plot outputs (first three segments for one animal)
plot(HMM_sgmt_crw, ask = FALSE,
animals = c("T172062_1", "T172062_2","T172062_3"))
plotPR(HMM_sgmt_crw)
# Chunk 29: MI_sim_10min_GPS
set.seed(1)
# simulate 4 realisations of the 10 min GPS CTCRW model
MI_sim_gps <- MIfitHMM(crw_gps_10, nSims = 4, fit = FALSE)
# plot locations for first narwhal
# filter first ID from original data
track <- tracks_gps %>%
mutate(x = st_coordinates(tracks_gps)[,"X"],
y = st_coordinates(tracks_gps)[,"Y"]) %>%
filter(ID == "T172062")
# filter first ID for each simulation
sim_tracks <- lapply(MI_sim_gps$miData, function(x){
filter(x, ID == "T172062")})
# plot original track for first narwhal
plot(track$x, track$y, col = "red", xlab = "x", ylab = "y", asp = 1, type = "l")
# plot each simulated track
mute <- mapply(function(data, col) {
points(y ~ x, data = data, col = col, type = "l")
}, data = sim_tracks,
col = list("cadetblue1", "cadetblue2", "cadetblue3", "cadetblue4"),
SIMPLIFY = FALSE)
# Chunk 30: count_ncores
# count number of available cores and use 60% of available cores
ncores <- parallel::detectCores()
ncores <- round(ncores*0.6)
# Chunk 31: fit_10min_GPS_MI
set.seed(1)
# fit multiple imputation HMM to the 10 min GPS crawl model
HMM_gps_MI <- MIfitHMM(crw_gps_10, nSims = 12, ncores = ncores,
nbStates = 2, dist = dist, Par0 = Par0, fit = TRUE)
# plot MI fits
plot(HMM_gps_MI, ask = FALSE, animals = "T172062")
# Chunk 32: sample_100_locs
set.seed(1)
# number of rows for each narwhal
tracks_gps_sub <- tracks_gps_ls %>%
lapply(function(x){
# number of rows for each narwhal
nrow <- nrow(x)
# rows to sample sorted chronologically
sub <- sort(c(1, nrow,  # first, last,
sample(2:(nrow-1), 98)))  # random 98 from the middle
# sample selection
x[sub,]
}) %>%
# convert back to a single data frame
do.call(rbind, .)
# Chunk 33: sample_crawl
set.seed(3)
# fit crawl
crw_gps_sub <- crawlWrap(obsData = tracks_gps_sub, timeStep = "10 mins")
# check that all parameters were estimated
crw_gps_sub$crwFits %>%
lapply(function(x){
x[c("par","se","ci")] %>%  # get estimated values
unlist() %>%  # unlist
is.nan() %>%  # identify values that failed to estimate
sum() == 0 # count failed estimates and ensure there are 0
})
crw_gps_sub
tracks_gps_sub
# fit MI HMM
HMM_gps_sub_MI <- MIfitHMM(crw_gps_sub, nSims = 80, ncores = 3,
nbStates = 2, dist = dist, Par0 = Par0, fit = TRUE)
set.seed(1)
# fit MI HMM
HMM_gps_sub_MI <- MIfitHMM(crw_gps_sub, nSims = 80, ncores = ncores,
nbStates = 2, dist = dist, Par0 = Par0, fit = TRUE)
# pool simulation results
MIpool_gps_sub <- MIpool(HMM_gps_sub_MI[[2]])
plot(MIpool_gps_sub, animals = "T172062")  # plot first narwhal
# compare states
sum(MIpool_gps_sub$Par$states ==
viterbi(HMM_gps_crw))/nrow(prep_gps_crw)
# fit MI HMM
HMM_gps_sub_MI <- MIfitHMM(crw_gps_sub, nSims = 80, ncores = ncores,
nbStates = 2, dist = dist, Par0 = Par0, fit = TRUE)
# Fit a 2 state HMM
set.seed(1)
HMM_gps_sub <- fitHMM(prep_gps_sub, nbState = 2, dist = dist, Par0 = Par0)
# compare states
sum(viterbi(HMM_gps_sub) ==
viterbi(HMM_gps_crw))/nrow(HMM_gps_sub$data)
tracks_gps_ls
crw_gps_10
set.seed(1)
# number of rows for each narwhal
tracks_gps_sub <- tracks_gps_ls %>%
lapply(function(x){
# number of rows for each narwhal
nrow <- nrow(x)
# rows to sample sorted chronologically
sub <- sort(c(1, nrow,  # first, last,
sample(2:(nrow-1), 98)))  # random 98 from the middle
# sample selection
x[sub,]
}) %>%
# convert back to a single data frame
do.call(rbind, .)
set.seed(3)
# fit crawl
crw_gps_sub <- crawlWrap(obsData = tracks_gps_sub, timeStep = "10 mins")
# check that all parameters were estimated
crw_gps_sub$crwFits %>%
lapply(function(x){
x[c("par","se","ci")] %>%  # get estimated values
unlist() %>%  # unlist
is.nan() %>%  # identify values that failed to estimate
sum() == 0 # count failed estimates and ensure there are 0
})
# prep data
prep_gps_sub <- prepData(data = crw_gps_sub)
prep_gps_sub
head(prep_gps_sub)
# fit multiple imputation HMM to the 10 min GPS crawl model
HMM_gps_MI <- MIfitHMM(crw_gps_10, nSims = 12, ncores = ncores,
nbStates = 2, dist = dist, Par0 = Par0, fit = TRUE)
head(crw_gps_10)
# Fit a 2 state HMM
set.seed(1)
HMM_gps_sub <- fitHMM(prep_gps_sub, nbState = 2, dist = dist, Par0 = Par0)
class(crw_gps_sub)
class(crw_gps_10)
head(crw_gps_sub)
head(crw_gps_10)
crw_gps_10$crwFits
crw_gps_10$crwPredict
set.seed(1)
# simulate 4 realisations of the 10 min GPS CTCRW model
MI_sim_gps <- MIfitHMM(crw_gps_10, nSims = 4, fit = FALSE)
# plot locations for first narwhal
# filter first ID from original data
track <- tracks_gps %>%
mutate(x = st_coordinates(tracks_gps)[,"X"],
y = st_coordinates(tracks_gps)[,"Y"]) %>%
filter(ID == "T172062")
# filter first ID for each simulation
sim_tracks <- lapply(MI_sim_gps$miData, function(x){
filter(x, ID == "T172062")})
# plot original track for first narwhal
plot(track$x, track$y, col = "red", xlab = "x", ylab = "y", asp = 1, type = "l")
# plot each simulated track
mute <- mapply(function(data, col) {
points(y ~ x, data = data, col = col, type = "l")
}, data = sim_tracks,
col = list("cadetblue1", "cadetblue2", "cadetblue3", "cadetblue4"),
SIMPLIFY = FALSE)
# plot original track for first narwhal
plot(track$x, track$y, col = "red", xlab = "x", ylab = "y", asp = 1, type = "l")
# plot each simulated track
mute <- mapply(function(data, col) {
points(y ~ x, data = data, col = col, type = "l")
}, data = sim_tracks,
col = list("cadetblue1", "cadetblue2", "cadetblue3", "cadetblue4"),
SIMPLIFY = FALSE)
# count number of available cores and use 60% of available cores
ncores <- parallel::detectCores()
ncores <- round(ncores*0.6)
set.seed(1)
# fit multiple imputation HMM to the 10 min GPS crawl model
HMM_gps_MI <- MIfitHMM(crw_gps_10, nSims = 12, ncores = ncores,
nbStates = 2, dist = dist, Par0 = Par0, fit = TRUE)
# plot MI fits
plot(HMM_gps_MI, ask = FALSE, animals = "T172062")
HMM_gps_MI <- MIfitHMM(crw_gps_10, nSims = 30, ncores = ncores,
nbStates = 2, dist = dist, Par0 = Par0, fit = TRUE)
# plot MI fits
plot(HMM_gps_MI, ask = FALSE, animals = "T172062")
#  b1,b2,b3,b4
stepDM <- matrix(c(1, 0, 0, 0,  # state 1 mean
0, 1, 0, 0,  # state 2 mean
0, 0, 1, 0,  # state 1 SD
0, 0, 0, 1), # state 2 SD
nrow = 4, ncol = 4,
byrow = TRUE)
rownames(stepDM) <- c("mu_1","mu_2","sd_1","sd_2")
colnames(stepDM) <- c("mu_1_i","mu_2_i", "sd_1_i","sd_2_i")
stepDM
#  b1,b2,b3
stepDM <- matrix(c(1, 0, 0,  # state 1 mean
1, 0, 0,  # state 2 mean
0, 1, 0,  # state 1 SD
0, 0, 1), # state 2 SD
nrow = 4, ncol = 3,
byrow = TRUE)
rownames(stepDM) <- c("mu_1","mu_2","sd_1","sd_2")
colnames(stepDM) <- c("mu_1.2_i", "sd_1_i","sd_2_i")
stepDM
# step DM
stepDM <- matrix(c(1,0,0,0,
1,1,0,0,  # Notice the two 1s
0,0,1,0,
0,0,0,1),
nrow = 4, ncol = 4,
byrow = TRUE)
rownames(stepDM) <- c("mu_1","mu_2","sd_1","sd_2")
colnames(stepDM) <- c("b1","b2", "b3","b4")
# work bound
stepWB <- matrix(c(-Inf, 0,  -Inf, -Inf,   # lower bounds
Inf, Inf, Inf,  Inf),  # upper bounds
nrow = ncol(stepDM), ncol = 2,
dimnames = list(colnames(stepDM),
c("lower","upper")))
# view
stepDM; stepWB
# create named lists for DM and workBounds
DM <- list(step = stepDM)
WB <- list(step = stepWB)
# convert starting parameters for step length to the working scale
Par0_WB <- list(step = log(Par0$step),
angle = Par0$angle)
Par0_WB$step[2] <- 0
# fit MI HMM
HMM_gps_sub_MI_WB <- MIfitHMM(crw_gps_sub, nSims = 10, ncores = ncores,
nbStates = 2, dist = dist, fit = T,
Par0 = Par0_WB, DM = DM, workBounds = WB)
# fit MI HMM
HMM_gps_sub_MI_WB <- MIfitHMM(crw_gps_10, nSims = 10, ncores = ncores,
nbStates = 2, dist = dist, fit = T,
Par0 = Par0_WB, DM = DM, workBounds = WB)
HMM_gps_sub_MI_WB
dives <- read.csv("data/dives.csv") %>%
mutate(time = ymd_hms(time)) %>%
filter(month(time) == 8, day(time) > 7,  day(time) <= 14)
head(dives)
table(dives$dt)
# regularise data
dives <- dives %>%
group_by(ID) %>%
# regularise time series by 1.25 min
summarise(time = seq(first(time), last(time), by = 1.25*60)) %>%
# merge regularised time with original dive
left_join(dives, by = c("ID", "time"))
dives_ls <- split(dives, dives$ID)
dive_TDR <- lapply(dives_ls, function(data){
createTDR(time = data$time, depth = data$depth,
dtime = 1.25*60, file = "data/dives.csv")
})
# generate interactive plot
plotTDR(dive_TDR[[1]]) # note: try zooming in to part of the dive
# calibrate TDR and identify dive phases
dive_TDR_calib <- lapply(X = dive_TDR, FUN = calibrateDepth,
zoc.method = "offset", offset = 0, dive.thr = 8)
# interactive plot of calibrated DTR
plotTDR(dive_TDR_calib[[1]], surface = TRUE)
plotTDR(dive_TDR_calib[[1]], diveNo = 1:300, surface = TRUE)
# calculate dive stats and add dive.id to each dive
dive_sum <- lapply(dive_TDR_calib, function(data){
mutate(diveStats(data, depth.deriv = FALSE), dive.id = row_number()) %>%
# select variables of interest
dplyr::select(dive.id, divetim, botttim, maxdep, bottdist, postdive.dur)})
# add dive.id with depth data to each depth record
dives_ls <- mapply(function(TDR, dives){
mutate(TDR, dive.id = dives@dive.activity$dive.id)
}, TDR = dives_ls, dives = dive_TDR_calib, SIMPLIFY = F)
# join TDR data with dive summary data
dives_ls <- mapply(function(TDR, dive_sum){
left_join(TDR, dive_sum, by = "dive.id")
}, TDR = dives_ls, dive_sum = dive_sum, SIMPLIFY = F)
# convert dive_ls back to a data.frame
dives_df <- do.call(rbind, dives_ls)
# replace NA bottom time of valid dives
dives_df$botttim[dives_df$dive.id > 0 & is.na(dives_df$botttim)] <- 75
# calculate proportion time at bottom
dives_df <- dives_df %>%
mutate(propbott = botttim/divetim)
# remove "dives" with no duration
dives_df <- dives_df %>%
filter(!(dive.id > 0 & is.na(divetim)))
options(warn=-1)
dives_sum <- dives_df %>%
# round time to same interval as location data
mutate(time = floor_date(time, "10 min")) %>%
# group rows by time interval
group_by(ID, time) %>%
# summarise data
summarise(NA_t          = sum(is.na(depth))*1.25,
surf_t        = sum(dive.id == 0)*1.25,
mean_dep      = ifelse(NA_t == 10, NA, mean(na.rm = T, depth)),
max_dep       = ifelse(NA_t == 10, NA, max(na.rm = T, depth)),
dive_t        = ifelse(NA_t == 10, NA, sum(na.rm = T, divetim)),
bott_t        = ifelse(dive_t < 5, NA, sum(na.rm = T, botttim)),
prop_bott     = ifelse(dive_t < 5, NA, max(na.rm = T, propbott)),
max_dive_dep  = ifelse(dive_t < 5, NA, max(na.rm = T, maxdep)),
bott_dist     = ifelse(dive_t < 5, NA, max(na.rm = T, bottdist)),
post_dive_dur = ifelse(dive_t < 5, NA, max(na.rm = T, postdive.dur))) %>%
# remove -Inf values (occur when no values for bottdist exist)
filter(!is.infinite(bott_dist))
# preview
head(dives_sum)
vars <- c("mean_dep","max_dep","dive_t","bott_t","prop_bott",
"max_dive_dep","bott_dist","post_dive_dur")
# First, missing data
dives_sum %>%
summarise(mean_dep      = sum(is.na(mean_dep)),          # 2
max_dep       = sum(is.na(max_dep)),           # 2
dive_t        = sum(is.na(dive_t)),            # 2
bott_t        = sum(is.na(bott_t)),            # 1
prop_bott     = sum(is.na(prop_bott)),         # 1
max_dive_dep  = sum(is.na(max_dive_dep)),      # 1
bott_dist     = sum(is.na(bott_dist)),         # 1
post_dive_dur = sum(is.na(post_dive_dur))) %>% # 1
# calculate total sum
{rbind(., c("Total:", colSums(.[,2:9])))} %>%
# output formatted table
kable(align = 'c') %>% kable_styling() %>%
row_spec(4, bold = T)
par(mfrow = c(4,2))
# in the distirbution
hist(log(dives_sum$mean_dep), 100,
main=NA, xlab = "mean depth")        # 2
par(mfrow = c(4,2))
# in the distirbution
hist(log(dives_sum$mean_dep), 100,
main=NA, xlab = "mean depth")        # 2
par(mfrow = c(4,2))
# in the distirbution
hist(log(dives_sum$mean_dep), 100,
main=NA, xlab = "mean depth")        # 2
hist(log(dives_sum$max_dep), 100,
main=NA, xlab = "max depth")         # 3
hist(log(dives_sum$dive_t), 100,
main=NA, xlab = "dive time")         # 1
hist(log(dives_sum$bott_t), 100,
main=NA, xlab = "bott time")         # 0
hist(logit(dives_sum$prop_bott), 100,
main=NA, xlab = "prop bottom")       # 0
hist(log(dives_sum$max_dive_dep), 100,
main=NA, xlab = "max dive depth")    # 2
hist(log(dives_sum$bott_dist), 100,
main=NA, xlab = "bott distance")     # 2
hist(log(dives_sum$post_dive_dur), 100,
main=NA, xlab = "post-dive duration")# 0
# Third, balanced autocorrelation
dives_sum_filter <- filter(dives_sum, ID == "T172062")
par(mfrow = c(4,2))
acf(dives_sum_filter$mean_dep, na.action = na.pass)       # 1
acf(dives_sum_filter$max_dep, na.action = na.pass)        # 2
acf(dives_sum_filter$dive_t, na.action = na.pass)         # 2
acf(dives_sum_filter$bott_t, na.action = na.pass)         # 0
acf(dives_sum_filter$prop_bott, na.action = na.pass)      # 0
acf(dives_sum_filter$max_dive_dep, na.action = na.pass)   # 1
acf(dives_sum_filter$bott_dist, na.action = na.pass)      # 1
acf(dives_sum_filter$post_dive_dur, na.action = na.pass)  # 0
# subjective score
data.frame(Variable = c("Mean depth", "Maximum depth", "Dive time",
"Bottom time", "Proportion at bottom",
"Maximum dive depth", "Bottom distance",
"Post-dive duration"),
Score = c(5, 6, 5,
1, 1, 4,
4, 1))
tracks_dives <- left_join(prep_tracks_gps_crw_NAgaps,
dives_sum[,c("ID", "time", "max_dep",
"dive_t", "mean_dep",
"max_dive_dep", "bott_dist")],
by = c("ID", "time"))
# calculate and plot check Paerson's correlation matrix
tracks_dives[,c("max_dep", "dive_t", "mean_dep", "max_dive_dep",
"bott_dist", "step", "angle")] %>%
na.omit() %>%
cor() %>%
corrplot(method="number")
layout(1)
# calculate and plot check Paerson's correlation matrix
tracks_dives[,c("max_dep", "dive_t", "mean_dep", "max_dive_dep",
"bott_dist", "step", "angle")] %>%
na.omit() %>%
cor() %>%
corrplot(method="number")
# identify whether there is 0 data
tracks_dives %>%
summarise(max_dep = sum(max_dep == 0, na.rm = T),
bott_dist = sum(bott_dist == 0, na.rm = T))
# starting parameters (will use same ones for both for now)
mu0 <- c(130, 180)  # mean
sigma0 <- c(60, 90)  # sd
zm <- c(0.1, 0.1)  # zero mass, where applicable
# fit dive-only HMMs
set.seed(1)
HMM_max_dep <- fitHMM(tracks_dives, nbStates = 2,
dist = list(max_dep = "gamma"),
Par0 = list(max_dep = c(mu0, sigma0)))
HMM_bott_dist <- fitHMM(tracks_dives, nbStates = 2,
dist = list(bott_dist = "gamma"),
Par0 = list(bott_dist = c(mu0, sigma0, zm)))
# prep model
stateNames = c("resident", "travel")
nbStates = length(stateNames)
dist = list(step = "gamma", angle = "vm",
max_dep = "gamma", bott_dist =  "gamma")
# Starting Pars
# view Pars from previous HMMs
getPar(HMM_gps_crw_NAgaps)$Par  # state 1 ~ resident, state 2 ~ travel
getPar(HMM_max_dep)$Par  # state 1 ~ travel, state 2 ~ resident
getPar(HMM_bott_dist)$Par  # state 1 ~ travel, state 2 ~ resident
# combine starting Pars
step0 <- getPar(HMM_gps_crw_NAgaps)$Par$step
angle0 <- getPar(HMM_gps_crw_NAgaps)$Par$angle
max_dep0 <- c(getPar(HMM_max_dep)$Par$max_dep[c(2,1)],  # mu1, mu2
getPar(HMM_max_dep)$Par$max_dep[c(4,3)])  # sd1, sd2
bott_dist0 <- c(getPar(HMM_bott_dist)$Par$bott_dist[c(2,1)],# mu1,mu2
getPar(HMM_bott_dist)$Par$bott_dist[c(4,3)],# sd1,sd2
getPar(HMM_bott_dist)$Par$bott_dist[c(6,5)])# zm1,zm2
Par0 <- list(step = step0, angle = angle0, max_dep = max_dep0,
bott_dist = bott_dist0)
# Fit 2-state Dive HMM
set.seed(1)
HMM_move_dive <- fitHMM(tracks_dives, nbStates=nbStates, stateNames=stateNames, dist=dist, Par0=Par0)
# plot output for first narwhal
plot(HMM_move_dive, breaks = 100, ask = FALSE, animals = "T172062")
plotPR(HMM_move_dive)
# define states
stateNames <- c("resident", "travel", "search")
nbStates <- length(stateNames)
# Starting Pars
# get Pars from last HMM_move_dive HMM
Pars <- getPar(HMM_move_dive)$Par
# combine starting Pars
step0 <- c(Pars$step[c(1,2)], mean(Pars$step[c(1,2)]),  # mu
Pars$step[c(3,4)], mean(Pars$step[c(3,4)]))  # sd
angle0 <- c(Pars$angle, 3)
max_dep0 <- c(Pars$max_dep[c(1,2)], 25,  # mu
Pars$max_dep[c(3,4)], 10)  # sd
bott_dist0 <- c(Pars$bott_dist[c(1,2)],  # mu
mean(Pars$bott_dist[c(1,2)]),
Pars$bott_dist[c(3,4)],  # sd
mean(Pars$bott_dist[c(3,4)]),
Pars$bott_dist[c(5,6)],  # zm
mean(Pars$bott_dist[c(5,6)]))
Par0 <- list(step = step0, angle = angle0, max_dep = max_dep0,
bott_dist = bott_dist0)
# fit 3-state HMM
set.seed(1)
HMM_move_dive_3s <- fitHMM(tracks_dives, nbStates=nbStates, stateNames=stateNames, dist=dist, Par0=Par0)
# plot output for first narwhal
plotPR(HMM_move_dive_3s)
plot(HMM_move_dive_3s, breaks = 100, ask = FALSE, animals = "T172062")
# plot output for first narwhal
plotPR(HMM_move_dive_3s)
# define states
stateNames <- c("forage", "travel", "rest", "search")
nbStates <- length(stateNames)
# Starting Pars
# get Pars from last HMM_move_dive HMM
Pars <- getPar(HMM_move_dive_3s)$Par
# combine starting Pars
step0 <- c(Pars$step[c(1:3)], mean(Pars$step[3]),  # mu
Pars$step[c(4:6)], mean(Pars$step[6]))  # sd
angle0 <- c(Pars$angle, Pars$angle[3])
max_dep0 <- c(Pars$max_dep[c(1:2)], Pars$max_dep[3]/2,  # mu
Pars$max_dep[3],
Pars$max_dep[c(4:5)], Pars$max_dep[6]/2,  # sd
Pars$max_dep[6])
bott_dist0 <- c(Pars$bott_dist[c(1:3)], Pars$bott_dist[3],  # mu
Pars$bott_dist[c(4:6)], Pars$bott_dist[6],  # sd
Pars$bott_dist[c(7:9)], Pars$bott_dist[9])  # zm
Par0 <- list(step = step0, angle = angle0, max_dep = max_dep0,
bott_dist = bott_dist0)
# fit 4-state HM
set.seed(1)
HMM_move_dive_4s <- fitHMM(tracks_dives, nbStates=nbStates,
stateNames=stateNames, dist=dist, Par0=Par0)
# view output for one narwhal
plotPR(HMM_move_dive_4s)
plot(HMM_move_dive_4s, breaks = 200, animals = "T172062")
?str_sub
library(dplyr)     # data management
library(tidyr)     # data management
library(stringr)   # character string management
library(data.table)# data management
library(lubridate) # date management
library(units)     # physical measurement units management
library(sf)        # spatial data processing
library(terra)     # raster data processing
library(tmap)      # mapping spatial data
library(diveMove)  # calculating dive metrics
library(earthtide) # estimating tidal data
library(corrplot)  # calculating Pearson's correlation matrices
library(momentuHMM)# fitting HMMs
library(conicfit)  # fitting error ellipses (required by momentuHMM)
library(car)       # additional operations to Applied Regression
library(mitools)   # parallel processing
library(doFuture)  # parallel processing
library(kableExtra)# produce visually appealing tables
?str_sub
hw <- "Hadley Wickham"
str_sub(hw, -1)
?summarize
library(dplyr)     # data management
library(tidyr)     # data management
library(stringr)   # character string management
library(data.table)# data management
library(lubridate) # date management
library(units)     # physical measurement units management
library(sf)        # spatial data processing
library(terra)     # raster data processing
library(tmap)      # mapping spatial data
library(diveMove)  # calculating dive metrics
library(earthtide) # estimating tidal data
library(corrplot)  # calculating Pearson's correlation matrices
library(momentuHMM)# fitting HMMs
library(conicfit)  # fitting error ellipses (required by momentuHMM)
library(car)       # additional operations to Applied Regression
library(mitools)   # parallel processing
library(doFuture)  # parallel processing
library(kableExtra)# produce visually appealing tables
?prepData
