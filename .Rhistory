c( "ID", "mu.x", "mu.y", "time")]
colnames(data) <- c( "ID","x", "y", "time")
# calculate time of day variable (for later use)
data$tod <- hour(data$time) + minute(data$time) / 60
# take a peak at the data
head(data)
# calculate step length and turning angles
data <- prepData(data, type = "UTM", covNames = "tod")
# take a peak at the data
head(data)
# calculate step length and turning angles
data <- prepData(data, type = "UTM", covNames = "tod")
# Get predicted tracks from crawl output
data <- crwOut$crwPredict[which(crwOut$crwPredict$locType == "p"),
c( "ID", "mu.x", "mu.y", "time")]
colnames(data) <- c( "ID","x", "y", "time")
# calculate time of day variable (for later use)
data$tod <- hour(data$time) + minute(data$time) / 60
# calculate step length and turning angles
data <- prepData(data, type = "UTM", covNames = "tod")
# take a peak at the data
head(data)
par(mfrow(1, 2))
par(mfrow= c(1, 2))
hist(data$step, 25)
hist(data$angle, 25)
par(mfrow= c(1, 2))
hist(data$step, 25, title = "", xlab = "step length (m)")
hist(data$angle, 25, title = "", xlab = "turning angle")
par(mfrow= c(1, 2))
hist(data$step, 25, main = "", xlab = "step length (m)")
hist(data$angle, 25, main = "", xlab = "turning angle")
plot(data$step ~ data$time, ty = "l", ylab = "Step length",
xlab = "Date", las = 1)
abline(h = 100, col = rgb(1, 0, 0, 0.5))
abline(h = 600, col = rgb(1, 0, 0, 0.5))
par(mfrow= c(1, 2))
hist(data$step, 25, main = "", xlab = "step length (m)")
hist(data$angle, 25, main = "", xlab = "turning angle")
dev.off()
plot(data$step ~ data$time, ty = "l", ylab = "Step length",
xlab = "Date", las = 1)
abline(h = 100, col = rgb(1, 0, 0, 0.5))
abline(h = 600, col = rgb(1, 0, 0, 0.5))
# define states (optional)
stateNames <- c("resident", "travel")
nbState <- length(stateNames)
# define distribution to use for each data stream
dist <- list(step = "gamma", angle = "vm")
# Setting up the starting values
mu0 <- c(100, 600) # Mean step length
sigma0 <- mu0/2 # SD of the step length
kappa0 <- c(0.1, 1) # Turn angle concentration parameter
# combine starting parameters
Par0 <- list(step = c(mu0, sigma0), angle = kappa0)
# Fit a 2 state HMM
mod <- fitHMM(data,
stateNames = stateNames,
nbState = 2,
dist = dist,
Par0 = Par0)
# Let's look at parameter estimates
mod
# plot state-dependent distributions
par(mfrow= c(1, 2))
plot(mod, ask = FALSE, plotTracks = FALSE)
# plot state-dependent distributions
par(mfrow= c(1, 2))
plot(mod, plotTracks = FALSE)
# plot state-dependent distributions
plot(mod, ask = FALSE, plotTracks = FALSE)
# Chunk 1: setup
knitr::opts_chunk$set(echo = TRUE)
# Chunk 2: Load packages
library(momentuHMM) # Package for fitting HMMs, builds on moveHMM
library(raster)     # For importing and extracting raster spatial covariates
library(dplyr)      # data management
library(tidyr)      # data management
library(ggOceanMaps)# plot the data
library(ggplot2)    # plot the data
library(ggspatial)  # plot the data
library(lubridate)  # transform numeric vectors to POSIXct objects.
library(sf)         # spatial data processing
library(kableExtra) # produce visually appealing tables
source("utility_functions.R")
# Chunk 4: import_tracks
tracks_gps <- read.csv("data/tracks_gps.csv")%>%
mutate(time = ymd_hms(time))
# Chunk 5: remove_missing_or_duplicate_data
tracks_gps <- tracks_gps %>%
# remove missing locations
filter(!is.na(x) & !is.na(y),
# remove identical records
!(time == lag(time) & x == lag(x) & y == lag(y) & loc_class == lag(loc_class)))
# Chunk 6: plot_gps_data
#Define the geographical limits (box) of the background map: c(min_lon,max_lon,min_lat,max_lat)
bbox <-c(min(tracks_gps$x),max(tracks_gps$x),min(tracks_gps$y),max(tracks_gps$y))
#Plot the data, with background map
basemap(limits = c(bbox), bathymetry = TRUE) +
geom_spatial_path(data = tracks_gps,
aes(x = x, y = y,colour=factor(ID)), crs = 4326)+
ggtitle("Movement data of the narwhals")
# Chunk 7: calc_dt
# Calculate time difference between locations
tracks_gps <- tracks_gps %>%
mutate(dt = ifelse(ID == lead(ID), # If next data row is same individual
# calculate time difference
difftime(lead(time), time, units = "mins"), NA))
# Chunk 8: calc_track_dt
# Visualise time differences (all and zoomed)
par(mfrow = c(1, 2))
hist(tracks_gps$dt, 1000, main = NA, xlab = "Time difference (min)")
hist(tracks_gps$dt, 1000, main = NA, xlab = "Time difference (min)", xlim = c(0,100))
# Chunk 9: calc_track_dt2
# identify the most frequent dt
tracks_gps %>%
{table(.$dt)} %>%
sort(decreasing = TRUE) %>%
head()
# Chunk 10: track_resolution_proportion_NA
# summarise track dt
tracks_gps %>%
group_by(ID) %>%
summarise(p_NA_10m = p_na(time, 10),     # 10 min
p_NA_20m = p_na(time, 20),     # 20 min
p_NA_30m = p_na(time, 30),     # 30 min
p_NA_60m = p_na(time, 60)) %>% # 60 min
# return formatted table
kable(digits = 3, col.names = c("Narwhal ID", paste(c(10,20,30,60), "m"))) %>%
kable_styling() %>%
add_header_above(c("", "Resolution" = 4))
# Chunk 11: segmentation
# Use function from utility_function.R to split data at gaps > 2 hours
data_split <- split_at_gap(data = tracks_gps,
max_gap = 60,
shortest_track = 20)
# Chunk 12: define_projection
data_sf <- data_split %>%
st_as_sf(coords = c("x", "y")) %>% # converts to an sf object
st_set_crs(4326) %>% # define CRS
st_transform(2962) # reproject data to a UTM
# Chunk 13: crawl_10_min_gps
# crawl can fail to fit periodically, so I recommend always setting a seed
set.seed(12)
# fit crawl
crwOut <- crawlWrap(obsData = data_sf, timeStep = "10 mins")
plot(crwOut, animals = "T172062-3", ask = FALSE)
# Get predicted tracks from crawl output
data <- crwOut$crwPredict[which(crwOut$crwPredict$locType == "p"),
c( "ID", "mu.x", "mu.y", "time")]
colnames(data) <- c( "ID","x", "y", "time")
# Chunk 14: prep
# calculate time of day variable (for later use)
data$tod <- hour(data$time) + minute(data$time) / 60
# Chunk 15: prep2
# calculate step length and turning angles
data <- prepData(data, type = "UTM", covNames = "tod")
# take a peak at the data
head(data)
# Chunk 16: inits
par(mfrow= c(1, 2))
hist(data$step, 25, main = "", xlab = "step length (m)")
hist(data$angle, 25, main = "", xlab = "turning angle")
# Chunk 17
par(mfrow= c(1, 1))
# Chunk 18: inits2
plot(data$step ~ data$time, ty = "l", ylab = "Step length",
xlab = "Date", las = 1)
abline(h = 100, col = rgb(1, 0, 0, 0.5))
abline(h = 600, col = rgb(1, 0, 0, 0.5))
# Chunk 19: inits3
# define states (optional)
stateNames <- c("resident", "travel")
nbState <- length(stateNames)
# define distribution to use for each data stream
dist <- list(step = "gamma", angle = "vm")
# Setting up the starting values
mu0 <- c(100, 600) # Mean step length
sigma0 <- mu0/2 # SD of the step length
kappa0 <- c(0.1, 1) # Turn angle concentration parameter
# combine starting parameters
Par0 <- list(step = c(mu0, sigma0), angle = kappa0)
# Chunk 20: fitHMM
# Fit a 2 state HMM
mod <- fitHMM(data,
stateNames = stateNames,
nbState = 2,
dist = dist,
Par0 = Par0)
# Let's look at parameter estimates
mod
# Chunk 21: plotHMM
# plot state-dependent distributions
plot(mod, ask = FALSE, plotTracks = FALSE)
# Chunk 22: viterbi
# Apply the Viterbi algorithm using your fited model object
dec_states <- viterbi(mod)
# Let's look at predicted states of the first 20 time steps
head(dec_states, 20)
# Chunk 23: statecounts
# How many locations in each state do we have?
table(dec_states)
# Chunk 24: stateprobs
# Calculate the probability of being in each state
statep <- stateProbs(mod)
# Let's look at the state probability matrix
head(statep)
# add column for the viterbi sequence and state probabilities
data$viterbi_state <- factor(dec_states)
data$state_p1 <- statep[,1]
# Plot tracks, coloured by viterbi states
ggplot(data, aes(x, y, col = viterbi_state, group = ID)) +
geom_point(size = 0.5) + geom_path() +
coord_equal() +
scale_color_manual(c("#E69F00", "#56B4E9"))
# Plot tracks, coloured by viterbi states
ggplot(data, aes(x, y, col = viterbi_state, group = ID)) +
geom_point(size = 0.5) + geom_path() +
coord_equal() +
scale_color_manual(values = c("#E69F00", "#56B4E9"))
# Plot tracks, coloured by state probabilities
ggplot(data, aes(x, y, group = ID, col = state_p1)) +
geom_point(size = 0.5) + geom_path() +
coord_equal() +
scale_color_continuous(low = "#E69F00", high = "#56B4E9")
# Plot tracks, coloured by state probabilities
ggplot(data, aes(x, y, group = ID, col = state_p1)) +
geom_point(size = 0.5) + geom_path() +
coord_equal() +
scale_color_continuous(high = "#E69F00", low = "#56B4E9")
# add column for the viterbi sequence and state probabilities
data$viterbi_state <- factor(dec_states)
data$state_p1 <- statep[,1]
# Plot tracks, coloured by viterbi states
ggplot(data, aes(x, y, col = viterbi_state, group = ID)) +
geom_point(size = 0.5) + geom_path() +
coord_equal() +
scale_color_manual(values = c("#E69F00", "#56B4E9"))
# Plot tracks, coloured by state probabilities
ggplot(data, aes(x, y, group = ID, col = state_p1)) +
geom_point(size = 0.5) + geom_path() +
coord_equal() +
scale_color_continuous(high = "#E69F00", low = "#56B4E9")
# Setting up the starting values
mu2 <- c(400, 600) # Mean step length
sigma2 <- mu2/2 # SD of the step length
kappa2 <- c(1, 1) # Turn angle concentration parameter
# combine starting parameters
Par0_2 <- list(step = c(mu2, sigma2), angle = kappa2)
# Fit the same 2 state HMM
mod2 <- fitHMM(data,
stateNames = stateNames,
nbState = 2,
dist = dist,
Par0 = Par0_2)
# Negative log likelihood
c(original = mod$mod$minimum, new = mod2$mod$minimum)
# Parameter estimates
list(original = mod$mle$step, new = mod2$mle$step)
list(mod$mle$angle, mod2$mle$angle)
list(mod$mle$gamma, mod2$mle$gamma)
# Negative log likelihood
c(original = mod$mod$minimum, new = mod2$mod$minimum)
# Parameter estimates
list(original = mod$mle$step, new = mod2$mle$step)
list(original = mod$mle$angle, new = mod2$mle$angle)
list(original = mod$mle$gamma, new = mod2$mle$gamma)
# add column for the viterbi sequence and state probabilities
data$viterbi_state <- factor(dec_states)
data$state_p1 <- statep[,1]
# Plot tracks, coloured by viterbi states
p1 <- ggplot(data, aes(x, y, col = viterbi_state, group = ID)) +
geom_point(size = 0.5) + geom_path() +
coord_equal() +
scale_color_manual(values = c("#E69F00", "#56B4E9"))
# Plot tracks, coloured by state probabilities
p2 <- ggplot(data, aes(x, y, group = ID, col = state_p1)) +
geom_point(size = 0.5) + geom_path() +
coord_equal() +
scale_color_continuous(high = "#E69F00", low = "#56B4E9")
plot_grid(p1, p2)
unlink("Tutorial_Narwhal_morning_cache", recursive = TRUE)
?setNA
adehabitatHR::setNA
?adehabitatHR
?adehabitatHR::setNA
??setNA
# Chunk 1: setup
knitr::opts_chunk$set(echo = TRUE)
# Chunk 2: Load packages
library(momentuHMM) # Package for fitting HMMs, builds on moveHMM
library(raster)     # For importing and extracting raster spatial covariates
library(dplyr)      # data management
library(tidyr)      # data management
library(ggOceanMaps)# plot the data
library(ggplot2)    # plot the data
library(ggspatial)  # plot the data
library(lubridate)  # transform numeric vectors to POSIXct objects.
library(sf)         # spatial data processing
library(kableExtra) # produce visually appealing tables
library(cowplot)
source("utility_functions.R")
setwd("~/Documents/1_Work/6_Conferences/CANSSI_2023/CANSSI_OTN_HMM_2023/Part1_Movement/Morning_Tutorial")
library(momentuHMM) # Package for fitting HMMs, builds on moveHMM
library(raster)     # For importing and extracting raster spatial covariates
library(dplyr)      # data management
library(tidyr)      # data management
library(ggOceanMaps)# plot the data
library(ggplot2)    # plot the data
library(ggspatial)  # plot the data
library(lubridate)  # transform numeric vectors to POSIXct objects.
library(sf)         # spatial data processing
library(kableExtra) # produce visually appealing tables
library(cowplot)
source("utility_functions.R")
tracks_gps <- read.csv("data/tracks_gps.csv")%>%
mutate(time = ymd_hms(time))
tracks_gps <- tracks_gps %>%
# remove missing locations
filter(!is.na(x) & !is.na(y),
# remove identical records
!(time == lag(time) & x == lag(x) & y == lag(y) & loc_class == lag(loc_class)))
#Define the geographical limits (box) of the background map: c(min_lon,max_lon,min_lat,max_lat)
bbox <-c(min(tracks_gps$x),max(tracks_gps$x),min(tracks_gps$y),max(tracks_gps$y))
#Plot the data, with background map
basemap(limits = c(bbox), bathymetry = TRUE) +
geom_spatial_path(data = tracks_gps,
aes(x = x, y = y,colour=factor(ID)), crs = 4326)+
ggtitle("Movement data of the narwhals")
# Calculate time difference between locations
tracks_gps <- tracks_gps %>%
mutate(dt = ifelse(ID == lead(ID), # If next data row is same individual
# calculate time difference
difftime(lead(time), time, units = "mins"), NA))
# Calculate time difference between locations
tracks_gps <- tracks_gps %>%
mutate(dt = ifelse(ID == lead(ID), # If next data row is same individual
# calculate time difference
difftime(lead(time), time, units = "mins"), NA))
# Visualise time differences (all and zoomed)
par(mfrow = c(1, 2))
hist(tracks_gps$dt, 1000, main = NA, xlab = "Time difference (min)")
hist(tracks_gps$dt, 1000, main = NA, xlab = "Time difference (min)", xlim = c(0,100))
# Calculate time difference between locations
tracks_gps <- tracks_gps %>%
mutate(dt = ifelse(ID == lead(ID), # If next data row is same individual
# calculate time difference
difftime(lead(time), time, units = "mins"), NA))
# Visualise time differences (all and zoomed)
par(mfrow = c(1, 2))
hist(tracks_gps$dt, 1000, main = NA, xlab = "Time difference (min)")
hist(tracks_gps$dt, 1000, main = NA, xlab = "Time difference (min)", xlim = c(0,100))
# Visualise time differences (all and zoomed)
par(mfrow = c(1, 2))
hist(tracks_gps$dt, 1000, main = NA, xlab = "Time difference (min)")
hist(tracks_gps$dt, 1000, main = NA, xlab = "Time difference (min)", xlim = c(0,100))
# identify the most frequent dt
tracks_gps %>%
{table(.$dt)} %>%
sort(decreasing = TRUE) %>%
head()
# summarise track dt
tracks_gps %>%
group_by(ID) %>%
summarise(p_NA_10m = p_na(time, 10),     # 10 min
p_NA_20m = p_na(time, 20),     # 20 min
p_NA_30m = p_na(time, 30),     # 30 min
p_NA_60m = p_na(time, 60)) %>% # 60 min
# return formatted table
kable(digits = 3, col.names = c("Narwhal ID", paste(c(10,20,30,60), "m"))) %>%
kable_styling() %>%
add_header_above(c("", "Resolution" = 4))
# summarise track dt
tracks_gps %>%
group_by(ID) %>%
summarise(p_NA_10m = p_na(time, 10),     # 10 min
p_NA_20m = p_na(time, 20),     # 20 min
p_NA_30m = p_na(time, 30),     # 30 min
p_NA_60m = p_na(time, 60)) %>% # 60 min
# return formatted table
kable(digits = 3, col.names = c("Narwhal ID", paste(c(10,20,30,60), "m"))) %>%
kable_styling() %>%
add_header_above(c("", "Resolution" = 4))
# Use function from utility_function.R to split data at gaps > 2 hours
data_split <- split_at_gap(data = tracks_gps,
max_gap = 60,
shortest_track = 20)
setwd("Morning_Tutorial")
# Chunk 1: setup
knitr::opts_chunk$set(echo = TRUE)
# Chunk 2: Load packages
library(momentuHMM) # Package for fitting HMMs, builds on moveHMM
library(raster)     # For importing and extracting raster spatial covariates
library(dplyr)      # data management
library(tidyr)      # data management
library(ggOceanMaps)# plot the data
library(ggplot2)    # plot the data
library(ggspatial)  # plot the data
library(lubridate)  # transform numeric vectors to POSIXct objects.
library(sf)         # spatial data processing
library(kableExtra) # produce visually appealing tables
source("utility_functions.R")
setwd("~/Documents/1_Work/6_Conferences/CANSSI_2023/CANSSI_OTN_HMM_2023/Part1_Movement/Morning_Tutorial")
# Chunk 1: setup
knitr::opts_chunk$set(echo = TRUE)
# Chunk 2: Load packages
library(momentuHMM) # Package for fitting HMMs, builds on moveHMM
library(raster)     # For importing and extracting raster spatial covariates
library(dplyr)      # data management
library(tidyr)      # data management
library(ggOceanMaps)# plot the data
library(ggplot2)    # plot the data
library(ggspatial)  # plot the data
library(lubridate)  # transform numeric vectors to POSIXct objects.
library(sf)         # spatial data processing
library(kableExtra) # produce visually appealing tables
source("utility_functions.R")
# Chunk 4: import_tracks
tracks_gps <- read.csv("data/tracks_gps.csv")%>%
mutate(time = ymd_hms(time))
# Chunk 5: remove_missing_or_duplicate_data
tracks_gps <- tracks_gps %>%
# remove missing locations
filter(!is.na(x) & !is.na(y),
# remove identical records
!(time == lag(time) & x == lag(x) & y == lag(y) & loc_class == lag(loc_class)))
# Chunk 6: plot_gps_data
#Define the geographical limits (box) of the background map: c(min_lon,max_lon,min_lat,max_lat)
bbox <-c(min(tracks_gps$x),max(tracks_gps$x),min(tracks_gps$y),max(tracks_gps$y))
#Plot the data, with background map
basemap(limits = c(bbox), bathymetry = TRUE) +
geom_spatial_path(data = tracks_gps,
aes(x = x, y = y,colour=factor(ID)), crs = 4326)+
ggtitle("Movement data of the narwhals")
# Chunk 7: calc_dt
# Calculate time difference between locations
tracks_gps <- tracks_gps %>%
mutate(dt = ifelse(ID == lead(ID), # If next data row is same individual
# calculate time difference
difftime(lead(time), time, units = "mins"), NA))
# Chunk 8: calc_track_dt
# Visualise time differences (all and zoomed)
par(mfrow = c(1, 2))
hist(tracks_gps$dt, 1000, main = NA, xlab = "Time difference (min)")
hist(tracks_gps$dt, 1000, main = NA, xlab = "Time difference (min)", xlim = c(0,100))
# Chunk 9: calc_track_dt2
# identify the most frequent dt
tracks_gps %>%
{table(.$dt)} %>%
sort(decreasing = TRUE) %>%
head()
# Chunk 10: track_resolution_proportion_NA
# summarise track dt
tracks_gps %>%
group_by(ID) %>%
summarise(p_NA_10m = p_na(time, 10),     # 10 min
p_NA_20m = p_na(time, 20),     # 20 min
p_NA_30m = p_na(time, 30),     # 30 min
p_NA_60m = p_na(time, 60)) %>% # 60 min
# return formatted table
kable(digits = 3, col.names = c("Narwhal ID", paste(c(10,20,30,60), "m"))) %>%
kable_styling() %>%
add_header_above(c("", "Resolution" = 4))
# Chunk 11: segmentation
# Use function from utility_function.R to split data at gaps > 2 hours
data_split <- split_at_gap(data = tracks_gps,
max_gap = 60,
shortest_track = 20)
# Chunk 12: define_projection
data_sf <- data_split %>%
st_as_sf(coords = c("x", "y")) %>% # converts to an sf object
st_set_crs(4326) %>% # define CRS
st_transform(2962) # reproject data to a UTM
# crawl can fail to fit periodically, so I recommend always setting a seed
set.seed(12)
# fit crawl
crwOut <- crawlWrap(obsData = data_sf, timeStep = "10 mins")
plot(crwOut, animals = "T172062-3", ask = FALSE)
plot(crwOut, animals = "T172062-2", ask = FALSE)
prepData(crwOut)
# Get predicted tracks from crawl output
data <- crwOut$crwPredict[which(crwOut$crwPredict$locType == "p"),
c( "ID", "mu.x", "mu.y", "time")]
data
crwOut$crwFits
# fit crawl
crwOut <- crawlWrap(obsData = data_sf, timeStep = "10 mins", theta = c(7, 0))
plot(crwOut, animals = "T172062-2", ask = FALSE)
plot(crwOut, animals = "T172062-3", ask = FALSE)
crwOut$crwPredict
data <- prepData(crwOut)
head(data)
crwOut
# Get predicted tracks from crawl output
data <- crwOut$crwPredict[which(crwOut$crwPredict$locType == "p"),
c( "ID", "mu.x", "mu.y", "time")]
head(dataa)
head(data)
diff(data$time)
data[105:110,]
foo <- diff(data$time)
plot(foo, col = data$ID)
plot(foo, col = as.integer(as.factor(data$ID)))
colnames(data) <- c( "ID","x", "y", "time")
head(data)
# calculate time of day variable (for later use)
data$tod <- hour(data$time) + minute(data$time) / 60
# calculate step length and turning angles
data <- prepData(data, type = "UTM", covNames = "tod")
# take a peak at the data
head(data)
unlink("Tutorial_Narwhal_morning_cache", recursive = TRUE)
