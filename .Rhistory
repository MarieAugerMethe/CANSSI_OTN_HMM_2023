kappa2 <- c(1, 1) # Turn angle concentration parameter
# combine starting parameters
Par0_2 <- list(step = c(mu2, sigma2), angle = kappa2)
# Fit the same 2 state HMM
mod2 <- fitHMM(data,
stateNames = stateNames,
nbState = 2,
dist = dist,
Par0 = Par0_2)
# Negative log likelihood
c(original = mod$mod$minimum, new = mod2$mod$minimum)
# Parameter estimates
cbind(mod$mle$step, mod2$mle$step)
cbind(mod$mle$angle, mod2$mle$angle)
cbind(mod$mle$gamma, mod2$mle$gamma)
# Negative log likelihood
c(original = mod$mod$minimum, new = mod2$mod$minimum)
# Parameter estimates
rbind(mod$mle$step, mod2$mle$step)
cbind(mod$mle$angle, mod2$mle$angle)
cbind(mod$mle$gamma, mod2$mle$gamma)
# Negative log likelihood
c(original = mod$mod$minimum, new = mod2$mod$minimum)
# Parameter estimates
list(mod$mle$step, mod2$mle$step)
cbind(mod$mle$angle, mod2$mle$angle)
cbind(mod$mle$gamma, mod2$mle$gamma)
# Negative log likelihood
c(original = mod$mod$minimum, new = mod2$mod$minimum)
# Parameter estimates
list(mod$mle$step, mod2$mle$step)
list(mod$mle$angle, mod2$mle$angle)
list(mod$mle$gamma, mod2$mle$gamma)
# Fit the same 2-state HMM with retryFits
# This is a random pertubation, so setting the seed to get the same results
set.seed(29)
mod_RF <- fitHMM(data,
nbState = 2,
dist=list(step="gamma", angle="vm"),
Par0 = Par0,
retryFits=10)
# Negative log likelihood
c(original = HMM_gps_crw_NAgaps$mod$minimum, new = HMM_gps_crw_NAgaps2$mod$minimum,
retryFits = HMM_RF$mod$minimum)
# Negative log likelihood
c(original = mod$mod$minimum, new = mod2$mod$minimum,
retryFits = mod_RF$mod$minimum)
# Setting up the starting values
mu3 <- c(100, 600, 1000) # Mean step length
sigma3 <- mu3/2 # SD of the step length
kappa3 <- c(0.1, 1, 1) # Turn angle concentration parameter
# combine starting parameters
Par0_3 <- list(step = c(mu3, sigma3), angle = kappa3)
# Fit the same 3 state HMM
mod_3state <- fitHMM(data,
nbState = 3,
Par0 = Par0_3)
# Setting up the starting values
mu3 <- c(100, 600, 1000) # Mean step length
sigma3 <- mu3/2 # SD of the step length
kappa3 <- c(0.1, 1, 1) # Turn angle concentration parameter
# combine starting parameters
Par0_3 <- list(step = c(mu3, sigma3), angle = kappa3)
# Fit the same 3 state HMM
mod_3state <- fitHMM(data,
nbState = 3,
dist = dist,
Par0 = Par0_3)
plot(mod_3state, animals = "T172062-3", ask = FALSE)
plotPR(mod_3state)
# set new formula
formula <- ~cosinor(tod, period = 24)
# set tpm formula and extract initial values from simpler model
Par0_4 <- getPar0(model = mod, formula = formula)
# calculate step length and turning angles
data <- prepData(data, type = "UTM")
# crawl can fail to fit periodically, so I recommend always setting a seed
set.seed(12)
# fit crawl
crwOut <- crawlWrap(obsData = data_sf, timeStep = "10 mins")
plot(crwOut, animals = "T172062-3", ask = FALSE)
# Get predicted tracks from crawl output
data <- crwOut$crwPredict[which(crwOut$crwPredict$locType == "p"),
c( "ID", "mu.x", "mu.y", "time")]
colnames(data) <- c( "ID","x", "y", "time")
# calculate step length and turning angles
data <- prepData(data, type = "UTM")
# calculate time of day variable (for later use)
data$tod <- hour(data$time) + minute(data$time) / 60
# take a peak at the data
head(data)
# Chunk 1: setup
knitr::opts_chunk$set(echo = TRUE)
# Chunk 2: Load packages
library(momentuHMM) # Package for fitting HMMs, builds on moveHMM
library(raster)     # For importing and extracting raster spatial covariates
library(dplyr)      # data management
library(tidyr)      # data management
library(ggOceanMaps)# plot the data
library(ggplot2)    # plot the data
library(ggspatial)  # plot the data
library(lubridate)  # transform numeric vectors to POSIXct objects.
library(sf)         # spatial data processing
library(kableExtra) # produce visually appealing tables
source("utility_functions.R")
# Chunk 4: import_tracks
tracks_gps <- read.csv("data/tracks_gps.csv")%>%
mutate(time = ymd_hms(time))
# Chunk 5: remove_missing_or_duplicate_data
tracks_gps <- tracks_gps %>%
# remove missing locations
filter(!is.na(x) & !is.na(y),
# remove identical records
!(time == lag(time) & x == lag(x) & y == lag(y) & loc_class == lag(loc_class)))
# Chunk 6: plot_gps_data
#Define the geographical limits (box) of the background map: c(min_lon,max_lon,min_lat,max_lat)
bbox <-c(min(tracks_gps$x),max(tracks_gps$x),min(tracks_gps$y),max(tracks_gps$y))
#Plot the data, with background map
basemap(limits = c(bbox), bathymetry = TRUE) +
geom_spatial_path(data = tracks_gps,
aes(x = x, y = y,colour=factor(ID)), crs = 4326)+
ggtitle("Movement data of the narwhals")
# Chunk 7: calc_dt
# Calculate time difference between locations
tracks_gps <- tracks_gps %>%
mutate(dt = ifelse(ID == lead(ID), # If next data row is same individual
# calculate time difference
difftime(lead(time), time, units = "mins"), NA))
# Chunk 8: calc_track_dt
# Visualise time differences
hist(tracks_gps$dt, 1000, main = NA, xlab = "Time difference (min)")
# Zoom in on short intervals
hist(tracks_gps$dt, 1000, main = NA, xlab = "Time difference (min)", xlim = c(0,100))
# identify the most frequent dt
tracks_gps %>%
{table(.$dt)} %>%
sort(decreasing = TRUE) %>%
head()
# Chunk 9: track_resolution_proportion_NA
# summarise track dt
tracks_gps %>%
group_by(ID) %>%
summarise(p_NA_10m = p_na(time, 10),     # 10 min
p_NA_20m = p_na(time, 20),     # 20 min
p_NA_30m = p_na(time, 30),     # 30 min
p_NA_60m = p_na(time, 60)) %>% # 60 min
# return formatted table
kable(digits = 3, col.names = c("Narwhal ID", paste(c(10,20,30,60), "m"))) %>%
kable_styling() %>%
add_header_above(c("", "Resolution" = 4))
# Chunk 10: segmentation
# Use function from utility_function.R to split data at gaps > 2 hours
data_split <- split_at_gap(data = tracks_gps,
max_gap = 60,
shortest_track = 20)
# Chunk 11: define_projection
data_sf <- data_split %>%
st_as_sf(coords = c("x", "y")) %>% # converts to an sf object
st_set_crs(4326) %>% # define CRS
st_transform(2962) # reproject data to a UTM
# Chunk 12: crawl_10_min_gps
# crawl can fail to fit periodically, so I recommend always setting a seed
set.seed(12)
# fit crawl
crwOut <- crawlWrap(obsData = data_sf, timeStep = "10 mins")
plot(crwOut, animals = "T172062-3", ask = FALSE)
# Get predicted tracks from crawl output
data <- crwOut$crwPredict[which(crwOut$crwPredict$locType == "p"),
c( "ID", "mu.x", "mu.y", "time")]
colnames(data) <- c( "ID","x", "y", "time")
# Chunk 13: prep
# calculate step length and turning angles
data <- prepData(data, type = "UTM")
# calculate time of day variable (for later use)
data$tod <- hour(data$time) + minute(data$time) / 60
# take a peak at the data
head(data)
# Chunk 14: inits
hist(data$step, 25)
hist(data$angle, 25)
# Chunk 15: inits2
plot(data$step ~ data$time, ty = "l", ylab = "Step length",
xlab = "Date", las = 1)
abline(h = 100, col = rgb(1, 0, 0, 0.5))
abline(h = 600, col = rgb(1, 0, 0, 0.5))
# Chunk 16: inits3
# define states (optional)
stateNames <- c("resident", "travel")
nbState <- length(stateNames)
# define distribution to use for each data stream
dist <- list(step = "gamma", angle = "vm")
# Setting up the starting values
mu0 <- c(100, 600) # Mean step length
sigma0 <- mu0/2 # SD of the step length
kappa0 <- c(0.1, 1) # Turn angle concentration parameter
# combine starting parameters
Par0 <- list(step = c(mu0, sigma0), angle = kappa0)
# Chunk 17: fitHMM
# Fit a 2 state HMM
mod <- fitHMM(data,
stateNames = stateNames,
nbState = 2,
dist = dist,
Par0 = Par0)
# Let's look at parameter estimates
mod
# Chunk 18: plotHMM
# plot outputs (for one animal)
plot(mod, ask = FALSE, animals = "T172062-3")
# Chunk 19: viterbi
# Apply the Viterbi algorithm using your fited model object
dec_states <- viterbi(mod)
# Let's look at predicted states of the first 20 time steps
head(dec_states, 20)
# Chunk 20: statecounts
# How many locations in each state do we have?
table(dec_states)
# Chunk 21: stateprobs
# Calculate the probability of being in each state
statep <- stateProbs(mod)
# Let's look at the state probability matrix
head(statep)
# Chunk 22: inits_check
# Setting up the starting values
mu2 <- c(400, 600) # Mean step length
sigma2 <- mu2/2 # SD of the step length
kappa2 <- c(1, 1) # Turn angle concentration parameter
# combine starting parameters
Par0_2 <- list(step = c(mu2, sigma2), angle = kappa2)
# Fit the same 2 state HMM
mod2 <- fitHMM(data,
stateNames = stateNames,
nbState = 2,
dist = dist,
Par0 = Par0_2)
# Chunk 23: comp
# Negative log likelihood
c(original = mod$mod$minimum, new = mod2$mod$minimum)
# Parameter estimates
list(mod$mle$step, mod2$mle$step)
list(mod$mle$angle, mod2$mle$angle)
list(mod$mle$gamma, mod2$mle$gamma)
# Chunk 24: retryfits
# Fit the same 2-state HMM with retryFits
# This is a random pertubation, so setting the seed to get the same results
set.seed(29)
mod_RF <- fitHMM(data,
nbState = 2,
dist=list(step="gamma", angle="vm"),
Par0 = Par0,
retryFits=10)
# Chunk 25: comp2
# Negative log likelihood
c(original = mod$mod$minimum, new = mod2$mod$minimum,
retryFits = mod_RF$mod$minimum)
# Chunk 26: plotpr
plotPR(mod)
# Chunk 27: 3states
# Setting up the starting values
mu3 <- c(100, 600, 1000) # Mean step length
sigma3 <- mu3/2 # SD of the step length
kappa3 <- c(0.1, 1, 1) # Turn angle concentration parameter
# combine starting parameters
Par0_3 <- list(step = c(mu3, sigma3), angle = kappa3)
# Fit the same 3 state HMM
mod_3state <- fitHMM(data,
nbState = 3,
dist = dist,
Par0 = Par0_3)
plot(mod_3state, animals = "T172062-3", ask = FALSE)
# Chunk 28: plotpr2
plotPR(mod_3state)
# set new formula
formula <- ~cosinor(tod, period = 24)
# set tpm formula and extract initial values from simpler model
Par0_4 <- getPar0(model = mod, formula = formula)
Par0_4
# fit model
m_tod_tpm <- fitHMM(prep_tracks_gps_crw_NAgaps,
nbStates=2,
dist=dist,
Par0=Par0_m2$Par,
beta0=Par0_m2$beta,
formula=formula)
# fit model
mod_tpm <- fitHMM(data,
nbStates=2,
dist=dist,
Par0=Par0_4$Par,
beta0=Par0_4$beta,
formula=formula)
mod_tpm$mle$beta
plotStationary(mod_tpm, plotCI = TRUE)
set.seed(1)
# define step formula and design matrix
DM <- list(step = list(mean = formula, sd = ~1))
# extract initial values from simpler 2-state model with no covariates
Par0_5 <- getPar0(model = mod, DM = DM)
# fit model
m_tod_obs <- fitHMM(data,
nbStates = 2,
dist = dist,
Par0 = Par0_5$Par,
beta0 = Par0_5$beta,
DM = DM)
m_tod_obs
# fit model
mod_obs <- fitHMM(data,
nbStates = 2,
dist = dist,
Par0 = Par0_5$Par,
beta0 = Par0_5$beta,
DM = DM)
mod_obs
plot(mod_obs, ask = F, plotCI = T, plotTracks = F)
AIC(mod)  # without time of day
AIC(mod_tpm)  # time of day effect on transition probabilities
AIC(mod_obs)  # time of day effect on observation parameters
unlink("Tutorial_Narwhal_morning_cache", recursive = TRUE)
dec_states
# add column for the viterbi sequence and state probabilities
data$viterbi_state <- factor(dec_states)
data$statep <- factor(statep)
viterbi_state
dec_states
# Chunk 1: setup
knitr::opts_chunk$set(echo = TRUE)
# Chunk 2: Load packages
library(momentuHMM) # Package for fitting HMMs, builds on moveHMM
library(raster)     # For importing and extracting raster spatial covariates
library(dplyr)      # data management
library(tidyr)      # data management
library(ggOceanMaps)# plot the data
library(ggplot2)    # plot the data
library(ggspatial)  # plot the data
library(lubridate)  # transform numeric vectors to POSIXct objects.
library(sf)         # spatial data processing
library(kableExtra) # produce visually appealing tables
source("utility_functions.R")
# Chunk 4: import_tracks
tracks_gps <- read.csv("data/tracks_gps.csv")%>%
mutate(time = ymd_hms(time))
# Chunk 5: remove_missing_or_duplicate_data
tracks_gps <- tracks_gps %>%
# remove missing locations
filter(!is.na(x) & !is.na(y),
# remove identical records
!(time == lag(time) & x == lag(x) & y == lag(y) & loc_class == lag(loc_class)))
# Chunk 6: plot_gps_data
#Define the geographical limits (box) of the background map: c(min_lon,max_lon,min_lat,max_lat)
bbox <-c(min(tracks_gps$x),max(tracks_gps$x),min(tracks_gps$y),max(tracks_gps$y))
#Plot the data, with background map
basemap(limits = c(bbox), bathymetry = TRUE) +
geom_spatial_path(data = tracks_gps,
aes(x = x, y = y,colour=factor(ID)), crs = 4326)+
ggtitle("Movement data of the narwhals")
# Chunk 7: calc_dt
# Calculate time difference between locations
tracks_gps <- tracks_gps %>%
mutate(dt = ifelse(ID == lead(ID), # If next data row is same individual
# calculate time difference
difftime(lead(time), time, units = "mins"), NA))
# Chunk 8: calc_track_dt
# Visualise time differences
hist(tracks_gps$dt, 1000, main = NA, xlab = "Time difference (min)")
# Zoom in on short intervals
hist(tracks_gps$dt, 1000, main = NA, xlab = "Time difference (min)", xlim = c(0,100))
# identify the most frequent dt
tracks_gps %>%
{table(.$dt)} %>%
sort(decreasing = TRUE) %>%
head()
# Chunk 9: track_resolution_proportion_NA
# summarise track dt
tracks_gps %>%
group_by(ID) %>%
summarise(p_NA_10m = p_na(time, 10),     # 10 min
p_NA_20m = p_na(time, 20),     # 20 min
p_NA_30m = p_na(time, 30),     # 30 min
p_NA_60m = p_na(time, 60)) %>% # 60 min
# return formatted table
kable(digits = 3, col.names = c("Narwhal ID", paste(c(10,20,30,60), "m"))) %>%
kable_styling() %>%
add_header_above(c("", "Resolution" = 4))
# Chunk 10: segmentation
# Use function from utility_function.R to split data at gaps > 2 hours
data_split <- split_at_gap(data = tracks_gps,
max_gap = 60,
shortest_track = 20)
# Chunk 11: define_projection
data_sf <- data_split %>%
st_as_sf(coords = c("x", "y")) %>% # converts to an sf object
st_set_crs(4326) %>% # define CRS
st_transform(2962) # reproject data to a UTM
# Chunk 12: crawl_10_min_gps
# crawl can fail to fit periodically, so I recommend always setting a seed
set.seed(12)
# fit crawl
crwOut <- crawlWrap(obsData = data_sf, timeStep = "10 mins")
plot(crwOut, animals = "T172062-3", ask = FALSE)
# Get predicted tracks from crawl output
data <- crwOut$crwPredict[which(crwOut$crwPredict$locType == "p"),
c( "ID", "mu.x", "mu.y", "time")]
colnames(data) <- c( "ID","x", "y", "time")
# Chunk 13: prep
# calculate step length and turning angles
data <- prepData(data, type = "UTM")
# calculate time of day variable (for later use)
data$tod <- hour(data$time) + minute(data$time) / 60
# take a peak at the data
head(data)
# Chunk 14: inits
hist(data$step, 25)
hist(data$angle, 25)
# Chunk 15: inits2
plot(data$step ~ data$time, ty = "l", ylab = "Step length",
xlab = "Date", las = 1)
abline(h = 100, col = rgb(1, 0, 0, 0.5))
abline(h = 600, col = rgb(1, 0, 0, 0.5))
# Chunk 16: inits3
# define states (optional)
stateNames <- c("resident", "travel")
nbState <- length(stateNames)
# define distribution to use for each data stream
dist <- list(step = "gamma", angle = "vm")
# Setting up the starting values
mu0 <- c(100, 600) # Mean step length
sigma0 <- mu0/2 # SD of the step length
kappa0 <- c(0.1, 1) # Turn angle concentration parameter
# combine starting parameters
Par0 <- list(step = c(mu0, sigma0), angle = kappa0)
# Chunk 17: fitHMM
# Fit a 2 state HMM
mod <- fitHMM(data,
stateNames = stateNames,
nbState = 2,
dist = dist,
Par0 = Par0)
# Let's look at parameter estimates
mod
# Chunk 18: plotHMM
# plot outputs (for one animal)
plot(mod, ask = FALSE, plotTracks = FALSE)
# Chunk 19: viterbi
# Apply the Viterbi algorithm using your fited model object
dec_states <- viterbi(mod)
# Let's look at predicted states of the first 20 time steps
head(dec_states, 20)
# Chunk 20: statecounts
# How many locations in each state do we have?
table(dec_states)
# Chunk 21: stateprobs
# Calculate the probability of being in each state
statep <- stateProbs(mod)
# Let's look at the state probability matrix
head(statep)
# add column for the viterbi sequence and state probabilities
data$viterbi_state <- factor(dec_states)
data$statep <- factor(statep)
# add column for the viterbi sequence and state probabilities
data$viterbi_state <- factor(dec_states)
data$statep <- factor(statep)
# Let's look at the state probability matrix
head(statep)
# add column for the viterbi sequence and state probabilities
data$viterbi_state <- factor(dec_states)
#data$statep <- factor(statep)
# Plot tracks, coloured by states
ggplot(data, aes(x, y, col = viterbi_state, group = ID)) +
geom_point(size = 0.5) + geom_path() +
coord_equal()
statep[,1]
data$state_p1 <- factor(statep[,1])
# add column for the viterbi sequence and state probabilities
data$viterbi_state <- factor(dec_states)
data$state_p1 <- factor(statep[,1])
# Plot tracks, coloured by viterbi states
ggplot(data, aes(x, y, col = viterbi_state, group = ID)) +
geom_point(size = 0.5) + geom_path() +
coord_equal()
# Plot tracks, coloured by state probabilities
ggplot(data, aes(x, y, col = state_p1, group = ID)) +
geom_point(size = 0.5) + geom_path() +
coord_equal()
# Plot tracks, coloured by state probabilities
ggplot(data, aes(x, y, group = ID)) +
geom_point(size = 0.5) + geom_path()
dev.off()
# Plot tracks, coloured by state probabilities
ggplot(data, aes(x, y, group = ID)) +
geom_point(size = 0.5) + geom_path()
# Plot tracks, coloured by state probabilities
ggplot(data, aes(x, y, group = ID, fill = state_p1)) +
geom_point(size = 0.5) + geom_path()
# add column for the viterbi sequence and state probabilities
data$viterbi_state <- factor(dec_states)
data$state_p1 <- factor(statep[,1])
# Plot tracks, coloured by viterbi states
ggplot(data, aes(x, y, col = viterbi_state, group = ID)) +
geom_point(size = 0.5) + geom_path() +
coord_equal()
# Plot tracks, coloured by state probabilities
ggplot(data, aes(x, y, group = ID, col = state_p1)) +
geom_point(size = 0.5) + geom_path()
# Plot tracks, coloured by state probabilities
ggplot(data, aes(x, y, group = ID, col = state_p1)) +
geom_point(size = 0.5) + geom_path() + coord_equal()
dev.off()
# Plot tracks, coloured by state probabilities
ggplot(data, aes(x, y, group = ID, col = state_p1)) +
geom_point(size = 0.5) + geom_path() +
coord_equal()
